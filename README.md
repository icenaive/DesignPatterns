#### 使用C++实现设计模式  
#### 创建型  
##### 简单工厂模式（计算器）
- 创建型：接受指令，创建出符合要求的实例
- 简单工厂：用于产生同一等级架构的产品（无法增加新的产品）
##### 工厂模式（雷锋）
- 定义一个用于创建对象的接口，让子类决定去实例化那个类
- 工厂方法把简单工厂的内部判断逻辑移到了客户端代码，本来需要修改工厂类，现在是修改客户端。
- 简单工厂模式在增加功能是会违反开放-封闭原则。工厂方法模式借助多态，克服了该缺点，却保持了封装对象创建过程的优点。
##### 原型模式（简历）
- 用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象
- 原型模式其实是从一个对象在创建另一个可定制的对象，而且不需要知道创建的细节
- 一般在初始化的信息不发生变化的情况下，克隆是最好的办法。既隐藏了创建的细节，又对性能有很大的提高。
- 原型模式不用重新初始化对象，而是获取对象运行时的状态。
- 原型抽象类的关键是有一个Clone()方法，原型具体类中复写Clone()创建当前对象的浅表副本。
- 在具体原型类中，MemberwiseClone()方法是浅拷贝，对值类型字段逐位拷贝，对引用类型只复制引用但不会把具体的对象值拷贝过来。原对象与他的副本引用同一个对象。
- 比起浅拷贝，深拷贝把引用对象的变量指向新对象，而不是原被引用的对象。对于需要深拷贝的每一层，都需要实现ICloneable原型模式。
- 深拷贝是把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象。
##### 创建者模式（小人）
- 建造者模式：将复杂对象的创建与表示分开，使得相同的创建过程可以有不同的表示。用户只需制定需要建造的类型，不需要知道建造的过程和细节。
- 指挥者是建造者模式中重要的类，用于控制建造过程，也可以隔离用户与建造过程的关联。
- 建造者隐藏了产品的组装细节，若需要改变一个产品的内部表示，可以再定义一个具体的建造者。
- 建造者模式是在当前创造复杂对象的算法，独立于该对象的组成部分和装配方式时适用的模式。
##### 抽象工厂模式（数据库）
- 抽象工厂模式提供一个创建一系列相关或相互依赖的接口，而无需指定他们具体的类
- 在客户端中，具体工厂类只在初始化是出现一次，更改产品系列就可以使用不同产品配置
- 利用简单工厂类替换抽象工厂类和子类，可以使客户端不再受不同系列的影响。
#### 行为型
##### 策略模式（商场销售）
- 面向对象中并非类越多越好，划分类是为了封装，但是分类的基础是抽象，相似的属性和功能的对象的抽象集合才是类
- 策略模式定义算法家族，分别封装，让他们之间可以替换。继承有助于析构公共的功能。这个模式让算法的变化不会影响到客户
- 策略模式和工厂模式结合，可以让客户端认识更少的类，降低耦合
- 策略模式可以简化单元测试，因为每个算法可以通过自己的借口单独测试
- 在不同时间内应用不同的业务规则，就可以考虑使用策略模式来处理
###### 模板方法（试卷）
- 模板方法模式：定义一个操作中的算法框架，将一些步骤延迟到子类中。子类在不改变框架的前提下就可以重新定义某些特定步骤。
- 当不变的和可变的行为在子类中混合在一起时，不变的部分就会重复出现，我们可以将不变的部分抽象成父类
##### 观察者模式（）
- 观察者模式定义了一种一对多的以来关系，让多个观察者对象同时监听某一个主题对象，当主题对象的状态发生改变时，会通知所有的观察者对象，让他们更新自己
- 当一个对象需要同时改变其他对象时，可以使用观察者模式，而且不知道有多少对象需要改变时，需要考虑使用观察者模式
- 观察者模式的工作是在解除耦合，让耦合的双方的都依赖于抽象，而不依赖于具体，从而使得各自的变化都不会影响另一边的变化。
- 委托就是一种引用方法类型。委托可看作函数的类，委托的实例代表具体函数。在主题对象内声明委托，不再依赖抽象观察者。
- 一个委托可以搭载多个相同原形和形式（参数和返回值）的方法，这些方法不需要属于一个类，且被依次唤醒。
##### 状态模式
- 分支过多导致方法过长违背了单一职责，承担了过多的职责;而且当需求变化时修改代码往往会违背开放-封闭原则，应该将分支变成一不同小类，将状态的判断逻辑转移到小类中。
- 状态模式：一个对象可能拥有多种状态，当内在状态改变时允许改变行为。
- 状态模式的好处是将与特定状态有关的行为局部化，并将不同状态的行为分隔开。
##### 备忘录模式
- 在不破坏封装性的前提下，捕获一个对象的内部状态，并在对象之外保存这个状态，这样以后可以将这个对象恢复到之前的状态。
- Orginator负责创建Memento，Memento封装Originator状态细节，Caretaker负责保管和交付Memento。
- 备忘录模式适用于需要维护历史状态的对象，或只需要保存原类属性中的小部分。
#### 结构型
##### 装饰模式（装饰）
- 动态的给一个对象添加一些额外的功能，就增加功能而言，比生成子类更加方便。
- 每个要装饰的功能放在单独的类中，并让这个类包装它所要修饰的对象。当需要执行特殊行为时，客户端就可以根据需要有选择的、有顺序的使用装饰功能包装对象了。
- 装饰模式有效的把类的核心职能和装饰功能区分开了，并且可以去除相关类中重复的装饰逻辑。
##### 代理模式(礼物)
- 为其他对象提供一种代理以控制对这个对象的访问。实际上是在访问对象时引入一定程度的间接性，通过代理访问对象。
- 应用场合：远程代理,为一个对象在不同的地址空间提供局部代表，隐藏一个对象存在于不同空间的事实;如.Net加入Web引用，引入WebService，此时项目会生成WebReference的文件夹，就是代理
- 虚拟代理：根据需要创建开销很大的对象，通过它存放实例化需很长时间的真实对象。HTML中的多图，就是通过虚拟代理代替了真实图片，存储路径和尺寸。
- 安全代理：控制真实对象的访问权限，用于对象应该拥有不同的访问权限时。
- 智能指引：当调用真实对象时，代理处理一些另外的事情。通过代理在访问对象时增加一些内务处理。
##### 外观模式（股票）
- 为子系统中的一组接口提供一个一致的界面,此模式定义了一个高层接口，这个接口使得子系统更加容易使用。
- 外观模式完美体现了依赖倒转原则和迪米特法则。
- 设计初期阶段，在MVC三层架构中，任意两层间建立外观Facade。
- 子系统会因不断演化变得复杂，增加外观Facade提供简单接口减少依赖。
- 在维护一个大的遗留系统时，新的开发又必须依赖其部分功能。此时，开发一个外观Facade类，从老系统中抽象出比较清晰的简单接口。让新系统只与Facade交互，而Facade与遗留代码交互所有的工作
##### 适配器模式
- 适配器模式：将一个类的接口转换为客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的可以一起工作
- 系统的数据和行为都正确的时候，但是接口不符合时，应该考虑使用适配器，目的是使控制范围之外的一个原有对象与某个接口匹配，主要用于府现原有的类，但是接口与现有环境不一样的情况。
- 当双方的类都不容易修改时，可以考虑使用适配器模式进行适配
