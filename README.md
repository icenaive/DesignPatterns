#### 使用C++实现设计模式  
#### 创建型  
##### 简单工厂模式（计算器）
- 创建型：接受指令，创建出符合要求的实例
- 简单工厂：用于产生同一等级架构的产品（无法增加新的产品）
##### 工厂模式（雷锋）
- 定义一个用于创建对象的接口，让子类决定去实例化那个类
- 工厂方法把简单工厂的内部判断逻辑移到了客户端代码，本来需要修改工厂类，现在是修改客户端。
- 简单工厂模式在增加功能是会违反开放-封闭原则。工厂方法模式借助多态，克服了该缺点，却保持了封装对象创建过程的优点。
##### 原型模式（简历）
- 用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象
- 原型模式其实是从一个对象在创建另一个可定制的对象，而且不需要知道创建的细节
- 一般在初始化的信息不发生变化的情况下，克隆是最好的办法。既隐藏了创建的细节，又对性能有很大的提高。
- 原型模式不用重新初始化对象，而是获取对象运行时的状态。
- 原型抽象类的关键是有一个Clone()方法，原型具体类中复写Clone()创建当前对象的浅表副本。
- 在具体原型类中，MemberwiseClone()方法是浅拷贝，对值类型字段逐位拷贝，对引用类型只复制引用但不会把具体的对象值拷贝过来。原对象与他的副本引用同一个对象。
- 比起浅拷贝，深拷贝把引用对象的变量指向新对象，而不是原被引用的对象。对于需要深拷贝的每一层，都需要实现ICloneable原型模式。
- 深拷贝是把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象。
##### 创建者模式（小人）
- 建造者模式：将复杂对象的创建与表示分开，使得相同的创建过程可以有不同的表示。用户只需制定需要建造的类型，不需要知道建造的过程和细节。
- 指挥者是建造者模式中重要的类，用于控制建造过程，也可以隔离用户与建造过程的关联。
- 建造者隐藏了产品的组装细节，若需要改变一个产品的内部表示，可以再定义一个具体的建造者。
- 建造者模式是在当前创造复杂对象的算法，独立于该对象的组成部分和装配方式时适用的模式。
##### 抽象工厂模式（数据库）
- 抽象工厂模式提供一个创建一系列相关或相互依赖的接口，而无需指定他们具体的类
- 在客户端中，具体工厂类只在初始化是出现一次，更改产品系列就可以使用不同产品配置
- 利用简单工厂类替换抽象工厂类和子类，可以使客户端不再受不同系列的影响。
##### 单例模式
- 让类自身保证它只有一个实例，并提供一个全局访问点。
- 多线程下可能失效，需要加锁保证只有一个线程进入临界区。采用双重锁定的方式，确保被锁定的进程同一时刻只被一个进程访问。
- 饿汉式单例：即静态初始化方式，在类初始化时产生私有单例对象，会提前占用资源；懒汉式单例：在第一次被引用时将自己初始化，会产生多线程访问安全问题，需要添加双重锁定。
#### 行为型
##### 策略模式（商场销售）
- 面向对象中并非类越多越好，划分类是为了封装，但是分类的基础是抽象，相似的属性和功能的对象的抽象集合才是类
- 策略模式定义算法家族，分别封装，让他们之间可以替换。继承有助于析构公共的功能。这个模式让算法的变化不会影响到客户
- 策略模式和工厂模式结合，可以让客户端认识更少的类，降低耦合
- 策略模式可以简化单元测试，因为每个算法可以通过自己的借口单独测试
- 在不同时间内应用不同的业务规则，就可以考虑使用策略模式来处理
###### 模板方法（试卷）
- 模板方法模式：定义一个操作中的算法框架，将一些步骤延迟到子类中。子类在不改变框架的前提下就可以重新定义某些特定步骤。
- 当不变的和可变的行为在子类中混合在一起时，不变的部分就会重复出现，我们可以将不变的部分抽象成父类
##### 观察者模式（）
- 观察者模式定义了一种一对多的以来关系，让多个观察者对象同时监听某一个主题对象，当主题对象的状态发生改变时，会通知所有的观察者对象，让他们更新自己
- 当一个对象需要同时改变其他对象时，可以使用观察者模式，而且不知道有多少对象需要改变时，需要考虑使用观察者模式
- 观察者模式的工作是在解除耦合，让耦合的双方的都依赖于抽象，而不依赖于具体，从而使得各自的变化都不会影响另一边的变化。
- 委托就是一种引用方法类型。委托可看作函数的类，委托的实例代表具体函数。在主题对象内声明委托，不再依赖抽象观察者。
- 一个委托可以搭载多个相同原形和形式（参数和返回值）的方法，这些方法不需要属于一个类，且被依次唤醒。
##### 迭代器模式
- 提供一种顺序访问一个聚合对象中各个元素，而且不暴露该对象的内部表示。
- 当你需要访问一个聚集对象，而且不管对象是什么的时候都需要遍历的时候，需要考虑使用迭代器模式。
- 迭代器模式分离了对象的遍历行为，既不暴露内部结构又可以让外部代码透明的访问集合内部的数据。
##### 状态模式
- 分支过多导致方法过长违背了单一职责，承担了过多的职责;而且当需求变化时修改代码往往会违背开放-封闭原则，应该将分支变成一不同小类，将状态的判断逻辑转移到小类中。
- 状态模式：一个对象可能拥有多种状态，当内在状态改变时允许改变行为。
- 状态模式的好处是将与特定状态有关的行为局部化，并将不同状态的行为分隔开。
##### 备忘录模式
- 在不破坏封装性的前提下，捕获一个对象的内部状态，并在对象之外保存这个状态，这样以后可以将这个对象恢复到之前的状态。
- Orginator负责创建Memento，Memento封装Originator状态细节，Caretaker负责保管和交付Memento。
- 备忘录模式适用于需要维护历史状态的对象，或只需要保存原类属性中的小部分。
##### 命令模式
- 将请求分装为对象，将请求与执行分开，可以用不同的请求对客户参数化。可以对请求排队，通过，否决，记录日志，撤销或者重做。
- 基于敏捷开发的原则，不要给代码添加基于猜测而实际不需要的功能，在需要的时候通过重构实现。
##### 中介者模式
- 用一个中介对象来封装一系列的对象交互。
- 中介者模式在系统中易用也容易被误用，当系统中出现多对多的交互复杂的对象群时，更应该考虑设计的问题
- 由于控制集中化，中介者模式将交互复杂性变成了中介者的复杂性，中介类会比任何一个同事类更复杂
- 中介者模式应用的场合有，一组对象以定义了好但复杂的方式进行通信，以及想定制一个分布在多个类中的行为却不想产生太多子类。
##### 解释器模式
- 给定一种语言，定义它文法的一种表示，再定义一个解释器，使用该表示来解释语言中的句子。
- 如果一种特定类型发生的频率足够高，就可以将其实例表达为一个句子，构建解释器来解析。
- 解释器模式就是用“迷你语言”来表现程序要解决的问题，将句子抽象为语法树。由于各个节电的类大体相同，便于修改、扩展和实现。
- 解释器为文法中的每条规则定义了一个类，当文法过多时将难以维护，建议使用其他技术如语法分析程序或编译器生成器处理。
##### 访问者模式
- 在不改变各元素的前提下定义作用于这些类的新的操作。
- 访问者模式使用双分派，将数据结构和作用于结构上的操作解耦，意味着执行的操作决定于请求的种类和接收者的状态。
- 如果系统具有较为稳定的数据结构，又有易于变化的算法操作，则适合使用访问者模式
#### 结构型
##### 装饰模式（装饰）
- 动态的给一个对象添加一些额外的功能，就增加功能而言，比生成子类更加方便。
- 每个要装饰的功能放在单独的类中，并让这个类包装它所要修饰的对象。当需要执行特殊行为时，客户端就可以根据需要有选择的、有顺序的使用装饰功能包装对象了。
- 装饰模式有效的把类的核心职能和装饰功能区分开了，并且可以去除相关类中重复的装饰逻辑。
##### 代理模式(礼物)
- 为其他对象提供一种代理以控制对这个对象的访问。实际上是在访问对象时引入一定程度的间接性，通过代理访问对象。
- 应用场合：远程代理,为一个对象在不同的地址空间提供局部代表，隐藏一个对象存在于不同空间的事实;如.Net加入Web引用，引入WebService，此时项目会生成WebReference的文件夹，就是代理
- 虚拟代理：根据需要创建开销很大的对象，通过它存放实例化需很长时间的真实对象。HTML中的多图，就是通过虚拟代理代替了真实图片，存储路径和尺寸。
- 安全代理：控制真实对象的访问权限，用于对象应该拥有不同的访问权限时。
- 智能指引：当调用真实对象时，代理处理一些另外的事情。通过代理在访问对象时增加一些内务处理。
##### 外观模式（股票）
- 为子系统中的一组接口提供一个一致的界面,此模式定义了一个高层接口，这个接口使得子系统更加容易使用。
- 外观模式完美体现了依赖倒转原则和迪米特法则。
- 设计初期阶段，在MVC三层架构中，任意两层间建立外观Facade。
- 子系统会因不断演化变得复杂，增加外观Facade提供简单接口减少依赖。
- 在维护一个大的遗留系统时，新的开发又必须依赖其部分功能。此时，开发一个外观Facade类，从老系统中抽象出比较清晰的简单接口。让新系统只与Facade交互，而Facade与遗留代码交互所有的工作
##### 适配器模式
- 适配器模式：将一个类的接口转换为客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的可以一起工作
- 系统的数据和行为都正确的时候，但是接口不符合时，应该考虑使用适配器，目的是使控制范围之外的一个原有对象与某个接口匹配，主要用于府现原有的类，但是接口与现有环境不一样的情况。
- 当双方的类都不容易修改时，可以考虑使用适配器模式进行适配
##### 组合模式
- 将对象组合成树形结构以表示部分与整体的层次结构，组合模式使得用户对单个对象和组合对象具有一致性
- 透明方法：叶子和分枝对外接口无差别；安全方法：分枝具有添加删除叶子的接口，低层抽象接口和叶子没有。
- 基本对象组合成组合，组合又可以被组合，不断递归下去，在任何用到基本对象的地方都可以使用组合对象。
##### 桥接模式
- 对象的继承关系编译时已确定，所以无法在运行时修改从父类继承的实现。由于紧耦合，父类中任何的改变必然会导致子类发生变化。当需要复用子类，但继承下来的方法不合适时，必须重写父类或用其他类替代。这种依赖性限制了灵活性和复用性。
- 合成／聚合复用原则：尽量使用合成和聚合而不是继承。可以保证每个类封装集中在单个任务上，不会出现规模太大的类及继承结构。
- 桥接模式：抽象类和其派生类分离，各自实现自己的对象。若系统可以从多角度分类，且每种分类都可能变化，则把多角度分离独立出来，降低耦合。
##### 享元模式
- 运用共享技术有效的支持大量细粒度的对象
- 在享元模式内部不随着环境改变的共享部分是内部状态，不可共享需要通过调用传递进来的参数是外部状态。
- 使用享元模式的场景包括，一个应用程序产生了大量的实例对象，占用了大量内存开销；或对象的大多数状态为外部状态，删除内部状态后可以用较少的共享对象来取代组对象。
- 应用场景有正则表达式、浏览器、机器人指令集等。